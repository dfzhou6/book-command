# B+树索引的使用

## B+树索引的代价
```
B+树索引在空间和时间上都有代价，因为每新建一个索引，索引中每条记录包含：索引列的值+主键值，这些都是占用空间的，而且当修改索引列时，也需要维护索引树，对记录进行分裂，移动。
```

## B+树索引适用场景
```
1. 全值匹配

2. 匹配左边的列
联合索引时优先匹配左边的列，关于列的位置不对，mysql会自动帮我们优化

3. 匹配左前缀
字符串列时，可使用左前缀

4. 匹配范围值

5. 精确匹配某一列+另一列范围

6. 覆盖索引
意思是要查的数据，就在索引树中，不需要回表，效率很高。

7. 排序
联合索引排序时，必须按照顺序
当左边列为常量时，也可以
当然ASC、DESC不能混用

8. 分组
同排序
```

## 顺序、随机IO
```
顺序IO：是指在索引树中的查找过程

随机IO：是指当使用2级索引时，回表时使用到的主键值，大多数情况都是随机顺序的，所以可能会访问不同不连续的页。
```

## 使用索引注意事项
```
1. 只为搜索、排序、分组的列创建索引

2. 考虑列的基数

3. 索引列的类型尽量小

4. 控制索引列的前缀值的长度(但会影响排序)

5. 只有索引列在比较表达式中单独出现才可以适用索引

6. 为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性

7. 定位并删除表中的重复和冗余索引

8. 尽量使用覆盖索引进行查询，避免回表带来的性能损耗
```

## 创建索引示例
```
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);  
```

